# 驱动中添加唤醒源

先在dts中添加 wakeup-source;
然后在驱动初始化过程中读取dts

```
pdata->wakeup_enable = of_property_read_bool(np,"wakeup-source");
```

因为我需要驱动深度休眠的情况下，在PL9发生中断的时候能够唤醒系统，所以有如下代码

```
static int fts_irq_registration(struct fts_ts_data *ts_data)
{
    int ret = 0;
    struct fts_ts_platform_data *pdata = ts_data->pdata;

    if(pdata->wakeup_enable)
    {
        ret = device_init_wakeup(ts_data->dev, true);
        if(ret < 0) {
            FTS_ERROR("Failed to init wakeup");
        }
        ret = dev_pm_set_wake_irq(ts_data->dev,gpio_to_irq(pdata->irq_gpio));
        if(ret < 0){
            FTS_ERROR("Failed to set wake irq");
        }
    }


    ts_data->irq = gpio_to_irq(pdata->irq_gpio);
    pdata->irq_gpio_flags = IRQF_TRIGGER_FALLING | IRQF_ONESHOT;
    FTS_INFO("irq:%d, flag:%x", ts_data->irq, pdata->irq_gpio_flags);
    ret = request_threaded_irq(ts_data->irq, NULL, fts_irq_handler,
                               pdata->irq_gpio_flags,
                               FTS_DRIVER_NAME, ts_data);

    return ret;
}
```

device_init_wakeup（）dev_pm_set_wake_irq() 配套使用

资源释放的时候就加入如下代码

```
if(ts_data->pdata->wakeup_enable)                                              
    {   
        device_init_wakeup(ts_data->dev, false);
        dev_pm_clear_wake_irq(ts_data->dev);
    }
```

经过测试当我给gpio口一个下拉的电平的时候，机器就能够从深度休眠 唤醒（这一点能从调试串口看出来，但是从设备显示屏上看不出来），所以当系统唤醒之后，如果给系统发送一个KEY_POWER就可以通过InputManagerService来点亮屏幕了。

